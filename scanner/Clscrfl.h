
//===========================================================================
//                CONTACTLESS CARD READER's FUNCTION LIBRARY
//===========================================================================

// Clscrfl.h : main header file for the CLSCRFL DLL

// Библиотека функций ридера бесконтактных смарт-карт включает в себя 
// следующие функции
//===========================================================================
//      ИНТЕРФЕЙС
//---------------------------------------------------------------------------
//  Создать интерфейс
//  Уничтожить интерфейс
//  Открыть RS-интерфейс
//  Открыть USB-интерфейс
//  Проверить, открыт ли интерфейс
//  Закрыть интерфейс
//  Выдать значение таймаута
//  Установить значение таймаута
//  Выдать код завершения последней операции
//===========================================================================
//      УПРАВЛЕНИЕ СЧИТЫВАТЕЛЕМ
//---------------------------------------------------------------------------
//  Выдать состояние считывателя
//  Включить микросхему-считыватель
//  Выключить микросхему-считыватель
//  Выдать версию микросхемы-считывателя
//  Выдать серийный номер микросхемы-считывателя
//  Сбросить электромагнитное поле считывателя
//  Установить режим модуляции электромагнитного поля считывателя
//  Управление звуковым сигналом
//  Управление светодиодом
//  Установить скорость обмена со считывателем по COM-порту
//===========================================================================
//      УПРАВЛЕНИЕ КАРТАМИ ТИПА 14443-A
//---------------------------------------------------------------------------
//  Активировать карту 14443-А из состояния IDLE
//  Деактивировать карту 14443-А в состояние HALT
//  Активировать карту 14443-А из состояния HALT
//===========================================================================
//      УПРАВЛЕНИЕ КАРТАМИ ТИПА 14443-B
//---------------------------------------------------------------------------
//  Активировать карты 14443-В из состояния IDLE
//  Выбрать карту 14443-В
//  Деактивировать карту 14443-В в состояние HALT
//  Активировать карты 14443-В из состояния HALT
//===========================================================================
//      УПРАВЛЕНИЕ МЕТКАМИ ТИПА 15693
//---------------------------------------------------------------------------
//  Произвести инвентаризацию меток 15693
//  Перевести метку 15693 в состояние QUIET
//===========================================================================
//      РАБОТА С КАРТАМИ Mifare Standard
//---------------------------------------------------------------------------
//  Кодировать ключ
//  Аутентифицировать сектор непосредственно
//  Записать ключ в EEPROM считывателя
//  Аутентифицировать сектор ключом из EEPROM
//  Прочитать блок
//  Записать блок
//  Уменьшить значение
//  Увеличить значение
//  Копировать значение
//===========================================================================
//      РАБОТА С КАРТАМИ Mifare Ultralight
//---------------------------------------------------------------------------
//  Прочитать страницу
//  Записать страницу
//===========================================================================
//      РАБОТА С МЕТКАМИ ТИПА 15693
//---------------------------------------------------------------------------
//  Прочитать блок
//  Записать блок


//===========================================================================
//      НЕПОСРЕДСТВЕННЫЙ ОБМЕН ДАННЫМИ
//---------------------------------------------------------------------------
//  Обмен данными со считывателем
//  Непосредственный обмен данными с картой
//===========================================================================
//      КОНФИГУРАЦИЯ УСТРОЙСТВ НА ШИНЕ RS485
//---------------------------------------------------------------------------
//  Выдать адрес обмена
//  Установить адрес обмена
//  Прочитать адрес устройства
//  Записать адрес устройства
//===========================================================================

// Наиболее часто встречающиеся коды возврата функций:
//          0 - успешное выполнение
// 0x80100001 - внутренняя ошибка считывателя, код которой можно получить 
//              путем вызова функции CLSCRF_GetLastInternalError



#if !defined(AFX_CLSCRFL_H__CE290562_87D9_41F4_A1CD_3B80EFEBA737__INCLUDED_)
#define AFX_CLSCRFL_H__CE290562_87D9_41F4_A1CD_3B80EFEBA737__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#ifdef CLSCRFL_EXPORTS
#define CLSCRFL_API __declspec(dllexport)
#else
#define CLSCRFL_API __declspec(dllimport)
#endif

#include "types_def.h"
#include "SCardErr.h"

#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const BYTE *LPCBYTE;
#endif

#define STRING_VERSION      "0.3"

//#define ADDRESS_RS_485      1

//                                  0    1    2    3    4    5    6    7
static DWORD cDecodeBufSize [] = {  16,  24,  32,  40,  48,  64,  96, 128, 
//                                  8    9   10   11   12   13   14   15
                                   256, 256, 256, 256, 256, 256, 256, 256 };

const unsigned char cPCD_FSDI = 5;        // PCD FIFO Size = 64

const DWORD cPCD_BufSize = cDecodeBufSize[cPCD_FSDI];

//
//
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//===========================================================================
//                          И Н Т Е Р Ф Е Й С
//===========================================================================
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Создать интерфейс
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Create( IN OUT LPVOID* ppReader );
//
// Создает объект-интерфейс
//
// ppReader - адрес переменной, в которую будет помещена ссылка на созданный
//            объект-интерфейс и которая будет использоваться в вызовах 
//            всех остальных функций
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
// Эта функция должна вызываться 1 раз в начале работы приложения
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Уничтожить интерфейс
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Destroy( IN LPVOID* ppReader );
//
// Уничтожает объект-интерфейс
//
// ppReader - адрес переменной, которая содержит ссылку на уничтожаемый
//            объект-интерфейс (см. функцию CLSCRF_Create )
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
// Эта функция должна вызываться 1 раз в конце работы приложения
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Открыть интерфейс
//---------------------------------------------------------------------------

CLSCRFL_API LONG __stdcall 
            CLSCRF_Open( IN LPVOID pReader,
                         IN DWORD  dwPortNumber = 0,
                         IN DWORD  dwBaudrate = 9600,
                         IN DWORD  dwLogFile = 0 );
//
// Устаревшая функция, оставлена только для совместимости с уже
// существующими приложениями. Для вновь разрабатываемых приложений
// следует пользоваться функциями CLSCRF_OpenRS и CLSCRF_OpenUSB
//
// Открывает интерфейс
//
// pReader      - ссылка на открываемый объект-интерфейс (см. функцию
//                CLSCRF_Create )
// dwPortNumber - выбор интерфейса: 0 - интерфейс USB
//                                  1 - последовательный порт COM1
//                                  2 - последовательный порт COM2
//                                  3 - последовательный порт COM3 и т.д.
// dwBaudrate   - скорость обмена по COM-порту
// dwLogFile    - вывод в файл хронологии обмена: 1 - создавать файл
//                                                0 - не создавать файл
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
// Эта функция должна вызываться 1 раз перед началом обмена со считывателем
// и каждый раз при изменении скорости обмена по COM-порту
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Открыть RS-интерфейс
//---------------------------------------------------------------------------

CLSCRFL_API LONG __stdcall 
            CLSCRF_OpenRS( IN LPVOID pReader,
                           IN DWORD  dwIndex = 0,
                           IN DWORD  dwBaudrate = 9600,
                           IN DWORD  dwLogFile = 0 );
//
// Открывает COM-порт (интерфейс RS232 или RS485)
//
// pReader    - ссылка на открываемый объект-интерфейс (см. функцию
//              CLSCRF_Create )
// dwIndex    - номер COM-порта от 0 ( 0 - COM1, 1 - COM2 и т.д.)
// dwBaudrate - скорость обмена по COM-порту
// dwLogFile  - вывод в файл хронологии обмена: 1 - создавать файл
//                                              0 - не создавать файл
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
// Эта функция должна вызываться 1 раз перед началом обмена со считывателем
// и каждый раз при изменении скорости обмена по COM-порту
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Открыть USB-интерфейс
//---------------------------------------------------------------------------

CLSCRFL_API LONG __stdcall 
            CLSCRF_OpenUSB( IN LPVOID pReader,
                            IN DWORD  dwIndex = 0,
                            IN DWORD  dwLogFile = 0 );
//
// Открывает USB-интерфейс
//
// pReader   - ссылка на открываемый объект-интерфейс (см. функцию
//             CLSCRF_Create )
// dwIndex   - номер USB-устройства в дереве устройств от 0
// dwLogFile - вывод в файл хронологии обмена: 1 - создавать файл
//                                             0 - не создавать файл
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
// Эта функция должна вызываться 1 раз перед началом обмена со считывателем
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Проверить, открыт ли интерфейс
//---------------------------------------------------------------------------
//
CLSCRFL_API bool __stdcall 
            CLSCRF_IsOpened( IN LPVOID pReader );
//
// Проверяет доступность интерфейса
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
//
// Возвращаемое значение:  0   - интерфейс закрыт
//                         1   - интерфейс открыт
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Закрыть интерфейс
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Close( IN LPVOID pReader );
//
// Закрывает интерфейс
//
// pReader - ссылка на закрываемый объект-интерфейс (см. функцию 
//           CLSCRF_Create )
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
// Эта функция должна вызываться 1 раз перед уничтожением интерфейса
// и каждый раз при изменении скорости обмена по COM-порту
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Выдать значение таймаута
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_GetIOTimeout( IN     LPVOID  pReader,
                                    OUT LPDWORD pdwTimeout );
//
// Выдает текущий интервал ожидания выполнения функций 
//
// pReader    - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pdwTimeout - адрес переменной типа DWORD, в которую будет помещено
//              значение таймаута в миллисекундах
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Установить значение таймаута
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_SetIOTimeout( IN LPVOID pReader,
                                 IN DWORD  dwTimeout );
//
// Время выполнения функций библиотеки складывается из следующих компонентов:
//    - передача команды из компьютера в считыватель
//    - выполнение команды в считывателе
//    - передача ответа из считывателя в компьютер
//    - накладные расходы операционной системы
// При создании интерфейса устанавливается таймаут, равный 1000 мс
// С помощью этой функции можно изменить интервал ожидания выполнения функций
//
// pReader   - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// dwTimeout - значение таймаута в миллисекундах. Если это значение равно 0,
//             то устанавливается таймаут по умолчанию (1000 мс)
//             Минимальное отличное от 0 значение таймаута 50 мс
//             Максимальное значение таймаута 86400000 мс
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Выдать код завершения последней операции
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_GetLastInternalError( IN     LPVOID pReader,
                                            OUT LPBYTE pbError );
//
// Если предыдущая функция данной библиотеки завершилась с кодом 0x80100001,
// значит произошла ошибка выполнения операции внутри считывателя
// Данная функция выдает значение кода этой внутренней ошибки
// Наиболее часто из внутренних ошибок встречается 0xff - карта не отвечает
//
// pReader  - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pbError  - адрес переменной типа unsigned char, в которую будет помещено
//            значение кода внутренней ошибки считывателя
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//===========================================================================
//              У П Р А В Л Е Н И Е   С Ч И Т Ы В А Т Е Л Е М
//===========================================================================
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Выдать состояние считывателя
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_GetState( IN     LPVOID  pReader,
                                OUT LPDWORD pdwState );
//
// Выдает состояние считывателя
//
// pReader  - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pdwState - ссылка на переменную типа DWORD, в которую будет помещено 
//            значение состояния устройства:
//
//  Биты 31-16 - резерв
//  Бит  15    - микросхема-считыватель включена
//  Бит  14    - электромагнитное поле включено
//  Биты 13-9  - резерв
//  Бит  8     - отключен сигнал при обнаружении карты
//  Биты 7-5   - резерв
//  бит  4     - режим ISO/IEC 14443-B
//  биты 3-2   - скорость приема (поток данных от карты к считывателю)
//               00 - 106 кбод
//               01 - 212 кбод
//               10 - 424 кбод
//               11 - 848 кбод
//  биты 1-0   - скорость передачи (поток данных от считывателя к карте)
//               00 - 106 кбод
//               01 - 212 кбод
//               10 - 424 кбод
//               11 - 848 кбод
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Включить микросхему-считыватель
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Mfrc_On( IN LPVOID pReader );
//
// Включает микросхему-считыватель
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
// Примечание. При включенной микросхеме-считывателе устройство потребляет 
// ток до 200 mA.
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Выключить микросхему-считыватель
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Mfrc_Off( IN LPVOID pReader );
//
// Выключает микросхему-считыватель
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
// Примечание. При выключенной микросхеме-считывателе устройство воспринимает
// команды, но не выполняет те из них, которые касаются этой микросхемы.
// Кроме того, в выключенном состоянии устройство потребляет значительно 
// меньший ток - около 25 mA.
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Выдать версию микросхемы-считывателя
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Get_Mfrc_Version( IN     LPVOID pReader,
                                        OUT LPBYTE pbMfrcVersion );
//
// Выдает код продукта (в т.ч. версию) микросхемы-считывателя
//
// pReader       - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pbMfrcVersion - адрес массива типа unsigned char, в который будет 
//                 помещено 6 байтов версии считывателя, из которых
//                 4 байта - код продукта микросхемы-считывателя
//                 1 байт  - версия микросхемы-считывателя
//                 1 байт  - версия микропрограммы считывателя
// Примеры:
//      Mfrc530   30 88 FE 03 04 01
//      Mfrc531   30 CC FF 0F 04 01
//      Mfrc632   30 FF FF 0F 04 01
//   где версия микросхемы 04, версия микропрограммы 01
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Выдать серийный номер микросхемы-считывателя
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Get_Mfrc_Serial_Number( IN     LPVOID pReader,
                                              OUT LPBYTE pbMfrcSN );
//
// Выдает серийный (уникальный) номер микросхемы-считывателя
//
// pReader  - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pbMfrcSN - адрес массива типа unsigned char, в который будет 
//            помещено 4 байта серийного номера
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Сбросить электромагнитное поле считывателя
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Mfrc_Rf_Off_On( IN LPVOID pReader,
                                   IN USHORT usDelay );
//
// Сбрасывает или выключает электромагнитное поле (ЭМП) считывателя
// Сброс ЭМП необходим для рестарта микросхемы транспондера
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// usDelay - интервал времени [мс], в течение которого ЭМП выключено. 
//           Если этот параметр равен 0, то ЭМП остается выключенным
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Установить режим модуляции электромагнитного поля считывателя
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Mfrc_Set_Rf_Mode( IN LPVOID pReader,
                                     IN BYTE   bRfMode );
//
// Устанавливает режим модуляции электромагнитного поля считывателя на 
// передачу команды и последующий прием ответа от карты
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bRfMode - байт режима модуляции ЭМП:
//    биты 7-4 - 0000 - режим ISO/IEC 14443-A
//               0001 - режим ISO/IEC 14443-B
//               0100 - режим ISO/IEC 15693
//    биты 3-2 - скорость приема (поток данных от карты к считывателю)
//               00 - 106 кбод
//               01 - 212 кбод
//               10 - 424 кбод
//               11 - 848 кбод
//    биты 1-0 - скорость передачи (поток данных от считывателя к карте)
//               00 - 106 кбод
//               01 - 212 кбод
//               10 - 424 кбод
//               11 - 848 кбод
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Управление звуковым сигналом
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Sound( IN LPVOID pReader,
                          IN BYTE   nBeepCount );
//
// Подает звуковой сигнал
//
// pReader    - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// nBeepCount - количество одиночных сигналов длительностью 100 мс с 
//              промежутками такой же длительности. Если равно 0, то 
//              автоматический сигнал при обнаружении карты отключается
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Управление светодиодом
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Led( IN LPVOID pReader,
                        IN BYTE   bBlinkColor,
                        IN BYTE   bBlinkCount,
                        IN BYTE   bPostColor );
//
// Мигает двухцветным светодиодом, затем гасит или зажигает его постоянно
// Частота миганий - 2 Гц
//
// pReader     - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bBlinkColor - цвет мигающего светодиода:
//                0   - не мигать
//                1   - мигать красным
//                2   - мигать зеленым
//                3   - мигать желто-оранжевым
// bBlinkCount - количество миганий (если 0 - не мигать)
// bPostColor  - последующее состояние светодиода:
//                0   - погасить
//                1   - зажечь красным
//                2   - зажечь зеленым
//                3   - зажечь желто-оранжевым
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Установить скорость обмена со считывателем по COM-порту
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_UART_Baudrate( IN LPVOID pReader,
                                  IN DWORD  dwBaudrate );
//
// Устанавливает скорость обмена со считывателем по COM-порту
//
// pReader    - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// dwBaudrate - новая скорость обмена по COM-порту; возможные значения:
//                  9600
//                 14400
//                 19200
//                 38400
//                 57600
//                115200
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//===========================================================================
//             У П Р А В Л Е Н И Е   К А Р Т А М И   Т И П А   A
//===========================================================================
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Активировать карту 14443-А из состояния IDLE
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Activate_Idle_A( IN     LPVOID  pReader,
                                       OUT LPBYTE  pbATQ,
                                       OUT LPBYTE  pbSAK,
                                       OUT LPBYTE  pbUID,
                                    IN OUT LPDWORD pdwUIDLength );
//
// Активирует карту 14443-А из состояния IDLE (см. ISO/IEC 14443-3 п.6.3)
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pbATQ   - ссылка на массив (2 байта), в которые будет помещен ATQ карты
// pbSAK   - ссылка на массив (1 байт), в который будет помещен SAK карты
// pbUID   - ссылка на массив не менее 10 байтов, в который будет
//           помещен уникальный идентификатор карты (UID)
// pdwUIDLength - ссылка на переменную типа DWORD, которая перед вызовом
//                функции должна содержать размер массива pbUID, а на выходе
//                будет содержать действительную длину уникального 
//                идентификатора карты, помещенного в массив pbUID
//                (возможные значения - 4, 7 или 10)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Деактивировать карту 14443-А в состояние HALT
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Halt_A( IN LPVOID pReader );
//
// Деактивирует карту 14443-А в состояние HALT (см. ISO/IEC 14443-3 п.6.3)
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Активировать карту 14443-А из состояния HALT
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Activate_Wakeup_A( IN     LPVOID  pReader,
                                      IN     LPBYTE  pbUID,
                                      IN     DWORD   UIDLength,
                                         OUT LPBYTE  pbATQ,
                                         OUT LPBYTE  pbSAK );

// Активирует карту 14443-А из состояния HALT (см. ISO/IEC 14443-3 п.6.3)
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pbUID   - ссылка на массив не менее 10 байтов, в котором перед вызовом 
//           функции должен быть помещен уникальный идентификатор карты (UID)
// UIDLength - длина уникального идентификатора карты, который содержится
//             в массиве pbUID
// pbATQ - ссылка на массив (2 байта), в которые будет помещен ATQ карты
// pbSAK - ссылка на массив (1 байт), в который будет помещен SAK карты
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//===========================================================================
//             У П Р А В Л Е Н И Е   К А Р Т А М И   Т И П А   B
//===========================================================================
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Активировать карты 14443-В из состояния IDLE
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Activate_Idle_B( IN     LPVOID  pReader,
                                    IN     BYTE    bAfi,
                                    IN     BYTE    bSni,
                                       OUT LPDWORD pdwPUPI,
                                       OUT LPDWORD pdwAppData,
                                       OUT LPDWORD pdwProtInfo,
                                    IN OUT LPDWORD pdwCardCount );
//
// Активирует карты 14443-В из состояния IDLE (см. ISO/IEC 14443-3 п.7.7)
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bAfi    - идентификатор семейства приложений
// bSni    - код количества временнЫх слотов (от 0 до 4), такой что 
//           количество слотов равно   2 ^ bSni
// pdwPUPI - ссылка на массив типа DWORD размером 16, в который будут
//           помещены псевдоуникальные идентификаторы обнаруженных карт,
//           по 4 байта для одной карты на элемент массива
// pdwAppData - ссылка на массив типа DWORD размером 16, в который будет
//              помещена информация о приложениях в обнаруженных картах,
//              по 4 байта для одной карты на элемент массива
// pdwProtInfo - ссылка на массив типа DWORD размером 16, в который будет
//               помещена информация о протоколах обнаруженных карт,
//               по 3 байта для одной карты на элемент массива в битах
//               с 0 по 23
// pdwCardCount - ссылка на переменную типа DWORD, которая перед вызовом
//                функции должна содержать размер массивов pdwPUPI, 
//                pdwAppData и pdwProtInfo, а на выходе будет содержать 
//                количество обнаруженных карт (от 0 до 16)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Выбрать карту 14443-В
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Attrib_B( IN     LPVOID  pReader,
                             IN     LPBYTE  pbPUPI,
                             IN     BYTE    bParam1,
                             IN     BYTE    bParam2,
                             IN     BYTE    bParam3,
                             IN     BYTE    bParam4,
                             IN OUT LPBYTE  pbHigherLayerBuf,
                             IN     DWORD   dwHLBufSize,
                             IN OUT LPDWORD pdwHLInfLength,
                                OUT LPBYTE  pbMbliCid );
//
// Выбирает карту 14443-В (см. ISO/IEC 14443-3 п.7.10) и назначает ей 
// логический идентификатор CID для  обмена по протоколу T = CL 
// (см. ISO/IEC 14443-4)
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pdwPUPI - ссылка на массив типа DWORD размером 16, в который будут
//           помещены псевдоуникальные идентификаторы обнаруженных карт,
//           по 4 байта для одной карты на элемент массива
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Деактивировать карту 14443-В в состояние HALT
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Halt_B( IN LPVOID pReader,
                           IN LPBYTE pbPUPI );
//
// Деактивирует карту 14443-В в состояние HALT (см. ISO/IEC 14443-3 п.7.12)
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pbPUPI  - ссылка на массив (4 байта), в котором находится
//           псевдоуникальный идентификатор деактивируемой карты
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Активировать карты 14443-В из состояния HALT
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Activate_Wakeup_B( IN     LPVOID  pReader,
                                      IN     BYTE    bAfi,
                                      IN     BYTE    bSni,
                                         OUT LPDWORD pdwPUPI,    //16*4 bytes
                                         OUT LPDWORD pdwAppData, //16*4 bytes
                                         OUT LPDWORD pdwProtInfo,//16*4 bytes
                                      IN OUT LPDWORD pdwCardCount );
//
// Активирует карты 14443-В из состояния HALT (см. ISO/IEC 14443-3 п.7.7)
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bAfi    - идентификатор семейства приложений
// bSni    - код количества временнЫх слотов (от 0 до 4), такой что 
//           количество слотов равно   2 ^ bSni
// pdwPUPI - ссылка на массив типа DWORD размером 16, в который будут
//           помещены псевдоуникальные идентификаторы обнаруженных карт,
//           по 4 байта для одной карты на элемент массива
// pdwAppData - ссылка на массив типа DWORD размером 16, в который будет
//              помещена информация о приложениях в обнаруженных картах,
//              по 4 байта для одной карты на элемент массива
// pdwProtInfo - ссылка на массив типа DWORD размером 16, в который будет
//               помещена информация о протоколах обнаруженных карт,
//               по 3 байта для одной карты на элемент массива в битах
//               с 0 по 23
// pdwCardCount - ссылка на переменную типа DWORD, которая перед вызовом
//                функции должна содержать размер массивов pdwPUPI, 
//                pdwAppData и pdwProtInfo, а на выходе будет содержать 
//                количество обнаруженных карт (от 0 до 16)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//===========================================================================
//     У П Р А В Л Е Н И Е   М Е Т К А М И   Т И П А   1 5 6 9 3
//===========================================================================
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Произвести инвентаризацию меток 15693
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Inventory_15693( IN     LPVOID  pReader,
                                    IN     BYTE    bFlags,
                                    IN     BYTE    bInventory,
                                    IN     BYTE    bAfi,
                                    IN     BYTE    bMaskLen,
                                    IN     LPCBYTE pbMaskVal, 
                                       OUT LPBYTE  pbRecvBuffer, 
                                    IN OUT LPDWORD pdwRecvLength );
//
// Производит инвентаризацию меток стандарта ISO/IEC 15693
// (см. ISO/IEC 15693-3 п.10.3.1)
//
// pReader       - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags        - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bInventory    - код команды Inventory (всегда равен 0x01)
// bAfi          - идентификатор семейства приложений
// bMaskLen      - количество битов маски
// pbMaskVal     - массив байтов, содержащий маску
// pbRecvBuffer  - массив для ответа от считывателя
// pdwRecvLength - ссылка на переменную типа DWORD, которая перед вызовом
//                 функции должна содержать размер массива pbRecvBuffer, 
//                 а на выходе будет содержать количество принятых от
//                 считывателя байтов по 1 или 16 временнЫм слотам
//
//      Для каждого временнОго слота в массиве pbRecvBuffer 
//      расположена следующая информация:
//
//      RetCode - код завершения запроса в этом слоте       - 1 байт
//      Count   - количество байтов, полученных от метки    - 1 байт
// Если Count отличен от 0, то далее следует ответ от метки
// (см. ISO/IEC 15693 п.10.3.1):
//      Flags                                               - 1 байт
//      DSFID                                               - 1 байт
//      UID                                                 - 8 байтов
// Если RetCode отличен от 0, то далее может присутствовать
//      CRC16                                               - 2 байта
//
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Перевести метку 15693 в состояние Quiet
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Stay_Quiet_15693( IN LPVOID pReader,
                                     IN BYTE   bFlags,
                                     IN BYTE   bStayQuiet,
                                     IN LPBYTE pbUID );
//
// Переводит метку в состояние Quiet (см. ISO/IEC 15693-3 п.10.3.2)
//
// pReader    - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags     - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bStayQuiet - код команды Stay Quiet (всегда равен 0x02)
// pbUID      - ссылка на массив (8 байтов), в котором находится
//              уникальный идентификатор метки
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Перевести метку 15693 в состояние Selected
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_Select_15693( IN     LPVOID pReader,
                                 IN     BYTE   bFlags,
                                 IN     BYTE   bSelect,
                                 IN     LPBYTE pbUID,
                                    OUT LPBYTE pbFlags,
                                    OUT LPBYTE pbErrorCode );
//
// Переводит метку в состояние Selected (см. ISO/IEC 15693-3 п.10.4.6)
//
// pReader     - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags      - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bSelect     - код команды Select (всегда равен 0x25)
// pbUID       - ссылка на массив (8 байтов), в котором находится
//               уникальный идентификатор метки
// pbFlags     - ссылка на переменную типа BYTE, в которую будут
//               помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbErrorCode - ссылка на переменную типа BYTE, в которую будет
//               помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Перевести метку 15693 в состояние Ready
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_ResetToReady_15693( IN     LPVOID pReader,
                                       IN     BYTE   bFlags,
                                       IN     BYTE   bResetToReady,
                                       IN     LPBYTE pbUID,
                                          OUT LPBYTE pbFlags,
                                          OUT LPBYTE pbErrorCode );
//
// Переводит метку в состояние Ready (см. ISO/IEC 15693-3 п.10.4.7)
//
// pReader       - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags        - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
//                 (рекомендуется включить флаг Select_flag)
// bResetToReady - код команды Reset to ready (всегда равен 0x26)
// pbUID         - ссылка на массив (8 байтов), в котором находится
//                 уникальный идентификатор метки, может быть равен NULL при
//                 включенном флаге Select_flag (рекомендуется)
// pbFlags       - ссылка на переменную типа BYTE, в которую будут
//                 помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbErrorCode   - ссылка на переменную типа BYTE, в которую будет
//                 помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//===========================================================================
//     Р А Б О Т А   С   К А Р Т А М И   M I F A R E   S T A N D A R D
//===========================================================================
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Кодировать ключ
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_MifareStandard_HostCodeKey( IN     LPVOID pReader,
                                               IN     LPBYTE pbUncoded,
                                                  OUT LPBYTE pbCoded );
//
// Кодирует ключ Mifare Standard
//
// pReader   - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pbUncoded - массив (6 байтов) исходного (некодированного) ключа
// pbCoded   - массив (12 байтов) кодированного ключа
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Аутентифицировать сектор непосредственно
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_MifareStandard_AuthKey( IN LPVOID pReader,
                                           IN BYTE   bAuthMode,
                                           IN LPBYTE pbUID,
                                           IN DWORD  dwSector,
                                           IN LPBYTE pbCodedKey );
//
// Производит аутентификацию сектора непосредственно заданным ключом
//
// pReader    - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bAuthMode  - тип ключа: 0x60 - Key A
//                         0x61 - Key B
// pbUID      - массив (4 байта), содержащий уникальный идентификатор карты
// dwSector   - номер аутентифицируемого сектора
// pbCodedKey - массив (12 байтов) кодированного ключа
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Записать ключ в EEPROM считывателя
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_MifareStandard_WriteKeyToE2( IN LPVOID pReader,
                                                IN BYTE   bKeyType,
                                                IN DWORD  dwSector,
                                                IN LPBYTE pbUncoded );
//
// Записывает ключ заданного типа для заданного сектора в EEPROM считывателя
//
// pReader   - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bKeyType  - тип ключа: 0x60 - Key A
//                        0x61 - Key B
// dwSector  - номер сектора, для которого записывается ключ
// pbUncoded - массив (6 байтов) некодированного ключа
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Аутентифицировать сектор ключом из EEPROM
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_MifareStandard_AuthE2( IN LPVOID pReader,
                                          IN BYTE   bAuthMode,
                                          IN LPBYTE pbUID,
                                          IN DWORD  dwSector );
//
// Производит аутентификацию сектора ключом, находящимся в EEPROM считывателя
//
// pReader    - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bAuthMode  - тип ключа: 0x60 - Key A
//                         0x61 - Key B
// pbUID      - массив (4 байта), содержащий уникальный идентификатор карты
// dwSector   - номер аутентифицируемого сектора
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Прочитать блок
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_MifareStandard_Read( IN     LPVOID pReader,
                                        IN     DWORD  dwSector,
                                        IN     DWORD  dwBlock,
                                           OUT LPBYTE pbRecvBuffer );
//
// Читает 16 байтов из заданного блока в заданном секторе
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// dwSector     - номер сектора, содержащего читаемый блок
// dwBlock      - номер читаемого блока
// pbRecvBuffer - массив (не менее 16 байтов) для прочитанного блока
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
// Перед вызовом этой функции должна быть проведена аутентификация сектора
// В каждом секторе блоки нумеруются от 0, например, для карты Mifare 1K 
// номер блока - это число от 0 до 3
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Записать блок
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_MifareStandard_Write( IN LPVOID pReader,
                                         IN DWORD  dwSector,
                                         IN DWORD  dwBlock,
                                         IN LPBYTE pbSendBuffer );
//
// Записывает 16 байтов в заданный блок в заданном секторе
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// dwSector     - номер сектора, содержащего записываемый блок
// dwBlock      - номер записываемого блока
// pbSendBuffer - массив (не менее 16 байтов) данных записываемого блока
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
// Перед вызовом этой функции должна быть проведена аутентификация сектора
// В каждом секторе блоки нумеруются от 0, например, для карты Mifare 1K 
// номер блока - это число от 0 до 3
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Уменьшить значение
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_MifareStandard_Decrement( IN LPVOID pReader,
                                             IN DWORD  dwSector,
                                             IN DWORD  dwSourceBlock,
                                             IN DWORD  dwValue,
                                             IN DWORD  dwTargetBlock );
//
// Уменьшает значение блока типа Value
//
// pReader       - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// dwSector      - номер сектора, содержащего читаемый блок
// dwSourceBlock - номер исходного блока
// dwValue       - вычитаемое, на которое уменьшается значение
// dwTargetBlock - номер блока-результата, может быть равен dwSourceBlock
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
// Перед вызовом этой функции должна быть проведена аутентификация сектора
// В каждом секторе блоки нумеруются от 0, например, для карты Mifare 1K 
// номер блока - это число от 0 до 3
// Блоки dwSourceBlock и dwTargetBlock должны принадлежать сектору dwSector
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Увеличить значение
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_MifareStandard_Increment( IN LPVOID pReader,
                                             IN DWORD  dwSector,
                                             IN DWORD  dwSourceBlock,
                                             IN DWORD  dwValue,
                                             IN DWORD  dwTargetBlock );
//
// Увеличивает значение блока типа Value
//
// pReader       - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// dwSector      - номер сектора, содержащего читаемый блок
// dwSourceBlock - номер исходного блока
// dwValue       - слагаемое, на которое увеличивается значение
// dwTargetBlock - номер блока-результата, может быть равен dwSourceBlock
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
// Перед вызовом этой функции должна быть проведена аутентификация сектора
// В каждом секторе блоки нумеруются от 0, например, для карты Mifare 1K 
// номер блока - это число от 0 до 3
// Блоки dwSourceBlock и dwTargetBlock должны принадлежать сектору dwSector
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Копировать значение
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_MifareStandard_Restore( IN LPVOID pReader,
                                           IN DWORD  dwSector,
                                           IN DWORD  dwSourceBlock,
                                           IN DWORD  dwTargetBlock );
//
// Копирует значение из одного блока типа Value в другой в заданном секторе
//
// pReader       - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// dwSector      - номер сектора, содержащего оба блока
// dwSourceBlock - номер исходного блока
// dwTargetBlock - номер блока-результата
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
// Перед вызовом этой функции должна быть проведена аутентификация сектора
// В каждом секторе блоки нумеруются от 0, например, для карты Mifare 1K 
// номер блока - это число от 0 до 3
// Блоки dwSourceBlock и dwTargetBlock должны принадлежать сектору dwSector
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//===========================================================================
//    Р А Б О Т А   С   К А Р Т А М И   M I F A R E   U L T R A L I G H T
//===========================================================================
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Прочитать страницу
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_MifareUltralight_Read( IN     LPVOID pReader,
                                          IN     BYTE   bPage,
                                             OUT LPBYTE pbRecvBuffer );
//
// Читает 4 байта из заданной страницы
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bPage        - номер читаемой страницы
// pbRecvBuffer - массив (не менее 4 байтов) для прочитанной страницы
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Записать страницу
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_MifareUltralight_Write( IN LPVOID pReader,
                                           IN BYTE   bPage,
                                           IN LPBYTE pbSendBuffer );
//
// Пишет 4 байта в заданную страницу
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bPage        - номер записываемой страницы
// pbSendBuffer - массив (не менее 4 байтов) данных записываемой страницы
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//===========================================================================
//     Р А Б О Т А   С   М Е Т К А М И   Т И П А   1 5 6 9 3
//===========================================================================
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Прочитать блок
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_ReadSingleBlock_15693( IN     LPVOID pReader,
                                          IN     BYTE   bFlags,
                                          IN     BYTE   bReadSingleBlock,
                                          IN     LPBYTE pbUID,
                                          IN     BYTE   bBlockNumber,
                                             OUT LPBYTE pbFlags,
                                             OUT LPBYTE pbBlockSecurityStatus,
                                             OUT LPBYTE pbData,
                                             OUT LPBYTE pbErrorCode );
//
// Читает 4 байта из заданного блока (см. ISO/IEC 15693-3 п.10.4.1)
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags       - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bReadSingleBlock - код команды Read Single Block (всегда равен 0x20)
// pbUID        - ссылка на массив (8 байтов), в котором находится
//                уникальный идентификатор метки
// bBlockNumber - номер читаемого блока (от 0)
// pbFlags      - ссылка на переменную типа BYTE, в которую будут
//                помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbBlockSecurityStatus - ссылка на переменную типа BYTE, в которую будет
//                         помещен статус защиты блока от записи
// pbData       - ссылка на массив (не менее 4 байтов) для прочитанного блока
// pbErrorCode  - ссылка на переменную типа BYTE, в которую будет
//                помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Записать блок
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_WriteSingleBlock_15693( IN     LPVOID pReader,
                                           IN     BYTE   bFlags,
                                           IN     BYTE   bWriteSingleBlock,
                                           IN     LPBYTE pbUID,
                                           IN     BYTE   bBlockNumber,
                                           IN     LPBYTE pbData,
                                              OUT LPBYTE pbFlags,
                                              OUT LPBYTE pbErrorCode );
//
// Записывает 4 байта в заданный блок (см. ISO/IEC 15693-3 п.10.4.2)
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags       - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bWriteSingleBlock - код команды Write Single Block (всегда равен 0x21)
// pbUID        - ссылка на массив (8 байтов), в котором находится
//                уникальный идентификатор метки
// bBlockNumber - номер записываемого блока (от 0)
// pbData       - ссылка на массив (не менее 4 байтов) записываемых даннных
// pbFlags      - ссылка на переменную типа BYTE, в которую будут
//                помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbErrorCode  - ссылка на переменную типа BYTE, в которую будет
//                помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Закрыть блок
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_LockBlock_15693( IN     LPVOID pReader,
                                    IN     BYTE   bFlags,
                                    IN     BYTE   bLockBlock,
                                    IN     LPBYTE pbUID,
                                    IN     BYTE   bBlockNumber,
                                       OUT LPBYTE pbFlags,
                                       OUT LPBYTE pbErrorCode );
//
// Предохраняет заданный блок от перезаписи (см. ISO/IEC 15693-3 п.10.4.3)
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags       - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bLockBlock   - код команды Lock Block (всегда равен 0x22)
// pbUID        - ссылка на массив (8 байтов), в котором находится
//                уникальный идентификатор метки
// bBlockNumber - номер закрываемого блока (от 0)
// pbFlags      - ссылка на переменную типа BYTE, в которую будут
//                помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbErrorCode  - ссылка на переменную типа BYTE, в которую будет
//                помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Прочитать несколько блоков
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_ReadMultipleBlocks_15693( IN     LPVOID pReader,
                                             IN     BYTE   bFlags,
                                             IN     BYTE   bReadMultipleBlock,
                                             IN     LPBYTE pbUID,
                                             IN     BYTE   bFirstBlockNumber,
                                             IN OUT LPBYTE pbNumberOfBlocks,
                                                OUT LPBYTE pbFlags,
                                                OUT LPBYTE pbBlockSecurityStatus,
                                                OUT LPBYTE pbData,
                                                OUT LPBYTE pbErrorCode );
//
// Читает несколько блоков (см. ISO/IEC 15693-3 п.10.4.4)
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags       - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bReadMultipleBlock - код команды Read Multiple Block (всегда равен 0x23)
// pbUID        - ссылка на массив (8 байтов), в котором находится
//                уникальный идентификатор метки
// bFirstBlockNumber - номер первого читаемого блока (от 0)
// pbNumberOfBlocks - ссылка на переменную типа BYTE, которая перед вызовом
//                    функции должна содержать количество (от 0) читаемых 
//                    блоков, а на выходе будет содержать количество 
//                    (тоже от 0) действительно прочитанных блоков
// pbFlags      - ссылка на переменную типа BYTE, в которую будут
//                помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbBlockSecurityStatus - ссылка на массив (до 256 байтов) типа BYTE, в 
//                         который будут помещены значения статуса защиты 
//                         блоков от записи (только при наличии флага 
//                         Option_flag)
// pbData       - ссылка на массив (до 8192 байтов) для прочитанных данных
//                (по 4 байта на каждый блок)
// pbErrorCode  - ссылка на переменную типа BYTE, в которую будет
//                помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Записать AFI
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_WriteAFI_15693( IN     LPVOID pReader,
                                   IN     BYTE   bFlags,
                                   IN     BYTE   bWriteAFI,
                                   IN     LPBYTE pbUID,
                                   IN     BYTE   bAFI,
                                      OUT LPBYTE pbFlags,
                                      OUT LPBYTE pbErrorCode );
//
// Записывает 1 байт AFI (см. ISO/IEC 15693-3 п.10.4.8)
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags       - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bWriteAFI    - код команды Write AFI (всегда равен 0x27)
// pbUID        - ссылка на массив (8 байтов), в котором находится
//                уникальный идентификатор метки
// bAFI         - записываемое значение AFI
// pbFlags      - ссылка на переменную типа BYTE, в которую будут
//                помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbErrorCode  - ссылка на переменную типа BYTE, в которую будет
//                помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Закрыть AFI
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_LockAFI_15693( IN     LPVOID pReader,
                                  IN     BYTE   bFlags,
                                  IN     BYTE   bLockAFI,
                                  IN     LPBYTE pbUID,
                                     OUT LPBYTE pbFlags,
                                     OUT LPBYTE pbErrorCode );
//
// Предохраняет AFI от перезаписи (см. ISO/IEC 15693-3 п.10.4.9)
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags       - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bLockAFI     - код команды Lock AFI (всегда равен 0x28)
// pbUID        - ссылка на массив (8 байтов), в котором находится
//                уникальный идентификатор метки
// pbFlags      - ссылка на переменную типа BYTE, в которую будут
//                помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbErrorCode  - ссылка на переменную типа BYTE, в которую будет
//                помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Записать DSFID
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_WriteDSFID_15693( IN     LPVOID pReader,
                                     IN     BYTE   bFlags,
                                     IN     BYTE   bWriteDSFID,
                                     IN     LPBYTE pbUID,
                                     IN     BYTE   bDSFID,
                                        OUT LPBYTE pbFlags,
                                        OUT LPBYTE pbErrorCode );
//
// Записывает 1 байт DSFID (см. ISO/IEC 15693-3 п.10.4.10)
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags       - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bWriteDSFID  - код команды Write DSFID (всегда равен 0x29)
// pbUID        - ссылка на массив (8 байтов), в котором находится
//                уникальный идентификатор метки
// bDSFID       - записываемое значение DSFID
// pbFlags      - ссылка на переменную типа BYTE, в которую будут
//                помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbErrorCode  - ссылка на переменную типа BYTE, в которую будет
//                помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Закрыть DSFID
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_LockDSFID_15693( IN     LPVOID pReader,
                                    IN     BYTE   bFlags,
                                    IN     BYTE   bLockDSFID,
                                    IN     LPBYTE pbUID,
                                       OUT LPBYTE pbFlags,
                                       OUT LPBYTE pbErrorCode );
//
// Предохраняет DSFID от перезаписи (см. ISO/IEC 15693-3 п.10.4.11)
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags       - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bLockDSFID   - код команды Lock DSFID (всегда равен 0x2a)
// pbUID        - ссылка на массив (8 байтов), в котором находится
//                уникальный идентификатор метки
// pbFlags      - ссылка на переменную типа BYTE, в которую будут
//                помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbErrorCode  - ссылка на переменную типа BYTE, в которую будет
//                помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Выдать системную информацию
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_GetSystemInfo_15693( IN     LPVOID pReader,
                                        IN     BYTE   bFlags,
                                        IN     BYTE   bGetSystemInfo,
                                        IN OUT LPBYTE pbUID,
                                           OUT LPBYTE pbFlags,
                                           OUT LPBYTE pbInfoFlags,
                                           OUT LPBYTE pbDSFID,
                                           OUT LPBYTE pbAFI,
                                           OUT LPWORD pbMemorySize,
                                           OUT LPBYTE pbICReference,
                                           OUT LPBYTE pbErrorCode );
//
// Выдает значения системной информации (см. ISO/IEC 15693-3 п.10.4.12)
//
// pReader        - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags         - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bGetSystemInfo - код команды Get System Information (всегда равен 0x2b)
// pbUID          - ссылка на массив (8 байтов), который перед вызовом
//                  функции может содержать уникальный идентификатор метки, а
//                  на выходе будет содержать уникальный идентификатор метки, 
//                  прочитанный как часть системной информации
// pbFlags        - ссылка на переменную типа BYTE, в которую будут
//                  помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbInfoFlags    - ссылка на переменную типа BYTE, в которую будут
//                  помещены флаги системной информации
// pbDSFID        - ссылка на переменную типа BYTE, в которую будет
//                  помещено значение DSFID
// pbAFI          - ссылка на переменную типа BYTE, в которую будет
//                  помещено значение AFI
// pbMemorySize   - ссылка на переменную типа WORD, в которую будет
//                  помещено значение
// pbICReference  - ссылка на переменную типа BYTE, в которую будет
//                  помещено значение
// pbErrorCode    - ссылка на переменную типа BYTE, в которую будет
//                  помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Выдать значения статуса защиты блоков от записи
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_GetMultipleBSS_15693( IN     LPVOID pReader,
                                         IN     BYTE   bFlags,
                                         IN     BYTE   bGetMultipleBSS,
                                         IN     LPBYTE pbUID,
                                         IN     BYTE   bFirstBlockNumber,
                                         IN OUT LPBYTE pbNumberOfBlocks,
                                            OUT LPBYTE pbFlags,
                                            OUT LPBYTE pbBlockSecurityStatus,
                                            OUT LPBYTE pbErrorCode );
//
// Выдает значения статуса защиты блоков от записи (block security status)
// (см. ISO/IEC 15693-3 п.10.4.13)
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags       - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bGetMultipleBSS - код команды Get Multiple Block Security Status
//                   (всегда равен 0x2c)
// pbUID        - ссылка на массив (8 байтов), в котором находится
//                уникальный идентификатор метки
// bFirstBlockNumber - номер первого читаемого блока (от 0)
// pbNumberOfBlocks - ссылка на переменную типа BYTE, которая перед вызовом
//                    функции должна содержать количество (от 0) читаемых 
//                    значений статуса защиты блоков от записи,
//                    а на выходе будет содержать количество 
//                    (тоже от 0) действительно прочитанных значений
// pbFlags      - ссылка на переменную типа BYTE, в которую будут
//                помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbBlockSecurityStatus - ссылка на массив (до 256 байтов) типа BYTE, в 
//                         который будут помещены значения статуса защиты 
//                         блоков от записи
// pbErrorCode  - ссылка на переменную типа BYTE, в которую будет
//                помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//



//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Установить EAS
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_SetEAS_15693( IN     LPVOID pReader,
                                 IN     BYTE   bFlags,
                                 IN     BYTE   bSetEAS,
                                 IN     BYTE   bICMfgCode,
                                 IN     LPBYTE pbUID,
                                    OUT LPBYTE pbFlags,
                                    OUT LPBYTE pbErrorCode );
//
// Устанавливает EAS в 1
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags       - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bSetEAS      - код команды Set EAS (всегда равен 0xa2)
// bICMfgCode   - код производителя микросхемы метки
// pbUID        - ссылка на массив (8 байтов), в котором находится
//                уникальный идентификатор метки
// pbFlags      - ссылка на переменную типа BYTE, в которую будут
//                помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbErrorCode  - ссылка на переменную типа BYTE, в которую будет
//                помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Сбросить EAS
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_ResetEAS_15693( IN     LPVOID pReader,
                                   IN     BYTE   bFlags,
                                   IN     BYTE   bResetEAS,
                                   IN     BYTE   bICMfgCode,
                                   IN     LPBYTE pbUID,
                                      OUT LPBYTE pbFlags,
                                      OUT LPBYTE pbErrorCode );
//
// Сбрасывает EAS в 0
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags       - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bResetEAS    - код команды Reset EAS (всегда равен 0xa3)
// bICMfgCode   - код производителя микросхемы метки
// pbUID        - ссылка на массив (8 байтов), в котором находится
//                уникальный идентификатор метки
// pbFlags      - ссылка на переменную типа BYTE, в которую будут
//                помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbErrorCode  - ссылка на переменную типа BYTE, в которую будет
//                помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Закрыть EAS
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_LockEAS_15693( IN     LPVOID pReader,
                                  IN     BYTE   bFlags,
                                  IN     BYTE   bLockEAS,
                                  IN     BYTE   bICMfgCode,
                                  IN     LPBYTE pbUID,
                                     OUT LPBYTE pbFlags,
                                     OUT LPBYTE pbErrorCode );
//
// Предохраняет EAS от перезаписи
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags       - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bLockEAS     - код команды Lock EAS (всегда равен 0xa4)
// bICMfgCode   - код производителя микросхемы метки
// pbUID        - ссылка на массив (8 байтов), в котором находится
//                уникальный идентификатор метки
// pbFlags      - ссылка на переменную типа BYTE, в которую будут
//                помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbErrorCode  - ссылка на переменную типа BYTE, в которую будет
//                помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Прочитать EAS
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_EASAlarm_15693( IN     LPVOID pReader,
                                   IN     BYTE   bFlags,
                                   IN     BYTE   bEASAlarm,
                                   IN     BYTE   bICMfgCode,
                                   IN     LPBYTE pbUID,
                                      OUT LPBYTE pbFlags,
                                      OUT LPBYTE pbEASData,
                                      OUT LPBYTE pbErrorCode );
//
// Читает EAS-последовательность, если бит EAS установлен в 1
//
// pReader      - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bFlags       - флаги запроса (см. ISO/IEC 15693-3 п.7.3.1)
// bEASAlarm    - код команды EAS Alarm (всегда равен 0xa5)
// pbUID        - ссылка на массив (8 байтов), в котором находится
//                уникальный идентификатор метки
// bICMfgCode   - код производителя микросхемы метки
// pbFlags      - ссылка на переменную типа BYTE, в которую будут
//                помещены флаги ответа (см. ISO/IEC 15693-3 п.7.4.1)
// pbEASData    - ссылка на массив (32 байта) для прочитанной 
//                EAS-последовательности
// pbErrorCode  - ссылка на переменную типа BYTE, в которую будет
//                помещен код ошибки (см. ISO/IEC 15693-3 п.7.4.2)
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//===========================================================================
//        Н Е П О С Р Е Д С Т В Е Н Н Ы Й   О Б М Е Н   Д А Н Н Ы М И
//===========================================================================
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Обмен данными со считывателем
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_DirectIO_Reader( IN     LPVOID  pReader,
                                    IN     LPCBYTE pbSendBuffer, 
                                    IN     DWORD   dwSendLength, 
                                       OUT LPBYTE  pbRecvBuffer, 
                                    IN OUT LPDWORD pdwRecvLength );
//
// Передает считывателю команду и принимает ответ на нее
//
// pReader       - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pbSendBuffer  - массив байтов, передаваемых считывателю
// dwSendLength  - количество передаваемых байтов
// pbRecvBuffer  - массив для ответа от считывателя
// pdwRecvLength - ссылка на переменную типа DWORD, которая перед вызовом
//                 функции должна содержать размер массива pbRecvBuffer, 
//                 а на выходе будет содержать количество принятых от
//                 считывателя байтов
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Непосредственный обмен данными с картой
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_DirectIO_Card( IN     LPVOID  pReader,
                                  IN     LPCBYTE pbSendBuffer, 
                                  IN     DWORD   dwSendLength, 
                                  IN     DWORD   dwTimeout,
                                     OUT LPBYTE  pbRecvBuffer, 
                                  IN OUT LPDWORD pdwRecvLength );
//
// Осуществляет передачу данных карте без предварительной обработки и 
// последующий прием данных от карты, в том числе при выполнении команд 
// карте по протоколу ISO/IEC 14443-4 (T=CL)
//
// pReader       - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pbSendBuffer  - массив байтов, передаваемых считывателю
// dwSendLength  - количество передаваемых в карту байтов
// dwTimeout     - величина таймаута карты в единицах (128 / 13,56)[мкс]
// pbRecvBuffer  - массив для ответа от считывателя
// pdwRecvLength - ссылка на переменную типа DWORD, которая перед вызовом
//                 функции должна содержать размер массива pbRecvBuffer, 
//                 а на выходе будет содержать количество принятых от
//                 считывателя байтов
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//#if ADDRESS_RS_485
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//===========================================================================
//   К О Н Ф И Г У Р А Ц И Я   У С Т Р О Й С Т В   Н А   Ш И Н Е   R S 4 8 5
//===========================================================================
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// Устройства на шине RS485 должны иметь разные адреса
// Адрес - это число от 0 до 255
// При создании интерфейса в качестве текущего устанавливается адрес 0
// На команду по адресу 0 считыватель отвечает независимо от своего адреса
// Команды по адресу 0 допустимы только в случае одного устройства на шине
// Перед обращением к другому устройству необходимо изменить адрес обмена
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Выдать адрес обмена
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_GetIOAddress( IN     LPVOID pReader,
                                    OUT LPBYTE pbIOAddr );
//
// Выдает адрес устройства, с которым производится обмен данными
//
// pReader  - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pbIOAddr - адрес переменной типа unsigned char, в которую будет помещен
//            адрес  устройства, с которым производится обмен данными
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Установить адрес обмена
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_SetIOAddress( IN LPVOID pReader,
                                 IN BYTE   bIOAddr );
//
// Задает адрес устройства, с которым будет производиться обмен данными
// Значение адреса 0 допустимо лишь при условии, что на шине RS485
// находится только один считыватель
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bIOAddr  - адрес устройства, с которым будет производиться обмен данными
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Прочитать адрес устройства
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_ReadDeviceAddress( IN     LPVOID pReader,
                                         OUT LPBYTE pbDevAddr );
//
// Выдает адрес устройства.
// Если адрес устройства неизвестен, необходимо оставить устройство на шине
// RS485 единственным, задать адрес обмена 0 (см. CLSCRF_SetIOAddress())
// и вызвать данную функцию.
//
// pReader   - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// pbDevAddr - адрес переменной типа unsigned char, в которую будет помещен
//             адрес  устройства
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//---------------------------------------------------------------------------
//  Записать адрес устройства
//---------------------------------------------------------------------------
//
CLSCRFL_API LONG __stdcall 
            CLSCRF_WriteDeviceAddress( IN LPVOID pReader,
                                       IN BYTE   bDevAddr );
//
// Задает устройству новый адрес и записывает его в энергонезависимой памяти
//
// pReader - ссылка на объект-интерфейс (см. функцию CLSCRF_Create )
// bDevAddr - новый адрес устройства
//
// Возвращаемое значение:  0   - успешное выполнение
//                       иначе - ошибка при выполнении
//
//#endif  // ADDRESS_RS_485
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLSCRFL_H__CE290562_87D9_41F4_A1CD_3B80EFEBA737__INCLUDED_)
